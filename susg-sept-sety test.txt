select decile, count(*), min(ref_num), max(ref_num) from (
select ref_num, ntile(5) over (order by ref_num) decile 
from subs_serv_groups
where trunc(suac_ref_num, -3) in (
select ref_num from accounts where bicy_cycle_code = 'MN2'
and ref_num NOT IN (SELECT TO_NUMBER (value_code) AS large_maac_ref_num
                                                          FROM bcc_domain_values
                                                         WHERE doma_type_code = 'LAMA')
)
)
group by decile

102	4837134
4837139	8252013
8252016	11217822
11217850	13031183
13031203	13796675
13796677	14251849
14251850	14606160
14606161	15145485
15145486	15369941
15369942	15815200

select /* MONITOR */ t1.* 
from table(xx_aj.get_list_susg_f (date '2018-08-01', date '2018-08-31', 14606161, 15145485, 'MN4')) t1

select * from table(xx_aj.get_list_susg_f (date '2018-08-01', date '2018-08-31', 
--102,
--13796675, 
--14251850,
--14606161,
--15145486,
--15369942,
--15815200, 
15373059,
15373059,
'MN4'))
where susg = 15373059

select a.* from subs_serv_groups susg ,accounts a
where susg.ref_num = 6458879
and trunc(susg.suac_ref_num, -3) = a.ref_num


select * from status_periods stpe
where 1=1 
--AND stpe.sety_ref_num = 5802234
AND NVL (stpe.end_date, date '2018-08-01' + 1) > date '2018-08-01'
AND stpe.start_date < date '2018-08-31' + 1
and susg_ref_num not in ( 
select gsm_susg_ref_num
from subs_packages supa
where 1=1
AND NVL (supa.end_date, date '2018-08-01' ) >= date '2018-08-01'
AND supa.start_date <= date '2018-08-31'
)

select * from fixed_term_contracts susp
where  1=1
AND NVL (susp.end_date, date '2018-08-01') >= date '2018-08-01'
AND susp.start_date <= date '2018-08-31'

select * from status_periods stpe
where 1=1 
susg_ref_num=4147989
AND NVL (stpe.end_date, date '2018-08-01') >= date '2018-08-01'
AND stpe.start_date <= date '2018-08-31'
order by 3

select susg_ref_num, start_date, end_date, trunc(start_date) +1 , nvl(trunc(end_date), date '2018-08-31')+ 1-1/24/60/60 
from ssg_statuses stpe
where  1=1
AND NVL (stpe.end_date, date '2018-08-01') >= date '2018-08-01'
AND stpe.start_date <= date '2018-08-31'
and status_code = 'AC'
and susg_ref_num = 15811504

with q1 as (
select lead(ssgs.start_date) over (partition by ssgs.susg_ref_num order by ssgs.start_date, ssgs.end_date) next_date,
lag(ssgs.end_date) over (partition by ssgs.susg_ref_num order by ssgs.end_date, ssgs.start_date) prev_date,
lead(ssgs.status_code) over (partition by ssgs.susg_ref_num order by ssgs.start_date, ssgs.end_date) next_status,
lag(ssgs.status_code) over (partition by ssgs.susg_ref_num order by ssgs.end_date, ssgs.start_date) prev_status,
ssgs.*
from ssg_statuses ssgs
where 1=1
and ssgs.susg_ref_num = 59976
)
select * from q1
where status_code = 'AC'
and start_date < date '2018-08-31' + 1
and coalesce(end_date, date '2018-08-01' + 1) > date '2018-08-01'
--and susg_ref_num =  15318911
--and end_date - start_date < 0.5

SELECT   LEAST (DECODE (ssst.status_code, 'TC', (ADD_MONTHS (ssst.start_date, 0) - 1), date '2018-08-31')
                        ,NVL (ssst.end_date, date '2018-08-31')
                        ,date '2018-08-31'
                        ) end_date
                 ,GREATEST (ssst.start_date, date '2018-08-01') start_date
                 ,ssst.status_code status_code
             FROM ssg_statuses ssst
            WHERE TRUNC (ssst.start_date) <= date '2018-08-31'   ----hh
              AND NVL (ssst.end_date, date '2018-08-01') >= date '2018-08-01'
              AND ssst.status_code IN ('AC', 'TC')
              AND ssst.susg_ref_num = 15790516
              --eeAND ssst.susg_ref_num = 15318911
         ORDER BY ssst.start_date;

select * from subs_packages supa
where  ((supa.end_date <= date '2018-08-31' AND supa.end_date >= date '2018-08-01') OR (supa.start_date >= date '2018-08-01' AND supa.start_date <= date '2018-08-31'))
and trunc(start_date) != trunc(nvl(end_date, date '2018-08-31' + 1))

select * from subs_service_parameters susp
where  ((susp.end_date <= date '2018-08-31' AND susp.end_date >= date '2018-08-01') OR (susp.start_date >= date '2018-08-01' AND susp.start_date <= date '2018-08-31'))
and trunc(start_date) != trunc(nvl(end_date, date '2018-08-31' + 1))
and 
susg_ref_num = 6542464

select decile, min(ref_num), max(ref_num) from (
select acco.ref_num, bicy_cycle_code, ntile(5) over (order by ref_num) decile  
from accounts acco, account_statuses acst
WHERE    1=1
     and bicy_cycle_code is not null
     and    acst.acco_ref_num=acco.ref_num
     and    acst.acst_code='AC'
     and    nvl(acst.end_date,sysdate)>=date '2018-08-01'
     and    acst.start_date<=date '2018-09-01'-1/24/60/60
     and    acco.ref_num not in (2025410000)
) where  bicy_cycle_code = 'MN2'
group by decile
;

select * from service_types
WHERE station_param = 'MINU'
AND station_type = 'TSV'

SELECT *
         FROM serv_package_types sept
--            , subs_packages      supa
         WHERE sept.special_mark = 'MEM'
--           AND sept.type_code = supa.sept_type_code


select ftco.*, mose.sety_ref_num mosety_ref_num from fixed_term_contracts ftco
, mixed_packet_orders  mipo
, mixed_order_services mose
where 1=1
AND ftco.mixed_packet_code = mipo.mixed_packet_code
AND ftco.ebs_order_number = mipo.ebs_order_number
AND Nvl(mipo.term_request_type, '*') <> 'NULLIFY'
AND mose.mipo_ref_num = mipo.ref_num


select calculate_fixed_charges.find_pack_days (date '2018-08-01', date '2018-08-31', 15790516, 0) from dual


with q1 as (
select lead(susp.start_date) over (partition by susp.susg_ref_num, susp.sety_ref_num order by susp.start_date) next_date, 
lag(susp.end_date) over (partition by susp.susg_ref_num, susp.sety_ref_num order by susp.start_date) prev_date,
susg_ref_num, sety_ref_num, greatest(trunc(start_date+1-1/24/60/60), date '2018-08-01') startd, least(coalesce(trunc(end_date), date '2018-08-31'), date '2018-08-31') endd, sepa_ref_num, sepv_ref_num 
,start_date , end_date 
from subs_service_parameters susp
where  1=1
and sety_ref_num = 5802234
--and susg_ref_num = 4838111
and trunc(susp.start_date+1-1/24/60/60) <= trunc(nvl(susp.end_date, date '2018-08-31'))
AND coalesce(susp.end_date, date '2018-08-01') >= date '2018-08-01'
AND susp.start_date <= date '2018-08-31'
--AND (coalesce(susp.end_date, date '2018-08-31'+1)  between date '2018-08-01' AND date '2018-08-31'
--OR susp.start_date between date '2018-08-01' AND date '2018-08-31')
)
select * from (
select susg_Ref_num, sety_ref_num, sepa_ref_num, 0 sepv_ref_num, date '2018-08-01' startd, startd-1 endd, start_date, end_date from q1
where prev_date is null and startd > date '2018-08-01'
union all
select susg_Ref_num, sety_ref_num, sepa_ref_num, 0 sepv_ref_num, endd+1 startd, nvl(next_date,date '2018-08-31') endd, start_date, end_date from q1
where endd < date '2018-08-31' and nvl(next_date,date '2018-08-31')  > endd+1 --next_date is null 
union all
select susg_Ref_num, sety_ref_num, sepa_ref_num, sepv_ref_num, startd, endd, start_date, end_date from q1
)
--where startd > date '2018-08-01' AND endd < date '2018-08-31'
order by 1

select * from emt_bill_price_list
where 1=1 
--and sety_ref_num = 5802234
and sept_type_code is null

--and sepv_ref_num in ()
and start_date < date '2018-09-01'


declare 
l_days_param NUMBER;
l_success BOOLEAN;
BEGIN
calculate_fixed_charges.get_num_of_days(date '2018-08-02', date '2018-08-02'+1-1/24/60/60, 15790516, 5802234, 2021, 2523, 0, l_days_param, l_success);
dbms_output.put_line(l_days_param || ' : ' );
end;  


declare
CURSOR c_ebpl(p_sept_type_code VARCHAR2, p_end_date DATE, p_start_date DATE) IS
SELECT   *
FROM emt_bill_price_list
WHERE chca_type_code IS NULL
AND sept_type_code = p_sept_type_code
AND sety_ref_num = 5802234
AND start_date <= p_end_date
AND NVL (end_date, p_start_date) >= p_start_date
ORDER BY start_date, end_date;
l_susg_serv_tab               get_susg_serv.t_susg_serv_tab;
l_serv                        get_susg_serv.t_susg_serv;
l_idx BINARY_INTEGER := 0;
l_sety_days NUMBER;
l_success BOOLEAN;
FUNCTION fetch_serv (
         p_serv  IN OUT NOCOPY  get_susg_serv.t_susg_serv
      )
         RETURN BOOLEAN IS
      -- Returns TRUE IF no more records found.
      BEGIN
         IF (l_susg_serv_tab.LAST >= l_idx) THEN   --works correct also IF (l_susg_serv_tab.Last IS NULL)
            p_serv := l_susg_serv_tab (l_idx);
            l_idx := l_idx + 1;
            RETURN FALSE;
         END IF;
         RETURN TRUE;
END fetch_serv;
begin
get_susg_serv.get_susg_serv (13745000, date '2018-08-01', date '2018-08-31', l_susg_serv_tab, 6458879);
l_idx := l_susg_serv_tab.FIRST;
  IF fetch_serv (l_serv) THEN
     --  dbms_output.put_line(To_Char(l_idx-1) || '. service NOT found');
     GOTO nothing_to_do_with_serv;
  END IF;
  LOOP
     if l_serv.sety_ref_num = 5802234 then
     dbms_output.put_line('INDEX:' || l_idx);
     dbms_output.put_line(l_serv.in_sept_type_code);
     dbms_output.put_line(l_serv.sety_ref_num);
     dbms_output.put_line(l_serv.start_date);
     dbms_output.put_line(l_serv.end_date);
     dbms_output.put_line(l_serv.susg_ref_num);
     FOR l_price_list IN c_ebpl(l_serv.in_sept_type_code, l_serv.start_date, l_serv.end_date) LOOP
         l_price_list.start_date := GREATEST (l_price_list.start_date, l_serv.start_date);
         l_price_list.end_date := LEAST (NVL (l_price_list.end_date, l_serv.end_date), l_serv.end_date);
         calculate_fixed_charges.get_num_of_days (l_price_list.start_date
                            ,l_price_list.end_date
                            ,l_serv.susg_ref_num
                            ,l_price_list.sety_ref_num
                            ,l_price_list.sepa_ref_num
                            ,l_price_list.sepv_ref_num
                            ,0   -- p_months_after NUMBER
                            ,l_sety_days
                            ,l_success
                            );
         --if l_sety_days > 0 then                   
         dbms_output.put_line(l_price_list.start_date || ' - ' || l_price_list.end_date || ' ' || l_price_list.charge_value || ' ' || l_price_list.sepv_ref_num);
         dbms_output.put_line(l_sety_days);
         --end if;
     END LOOP;
     end if;
     IF fetch_serv (l_serv) THEN   --also fetches the record
        --  dbms_output.put_line(To_Char(l_idx) || '. service NOT found inside loop');
        EXIT;
     END IF;
  END LOOP;
  <<nothing_to_do_with_serv>>
  null;
end;

